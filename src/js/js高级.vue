<template>
    <div class="content">
        <button @click="buttonClick">点击触发事件</button>
    </div>
</template>

<script>
// 基本数据类型 string number boolean undefined定义没赋值  null
// 引用数据类型 object function Array
// 判断类型 typeof返回字符串类型的表达 instanceof判断具体对象类型 ===判断undefined和null
// typeof 判断null是object  是有问题的 ，1、null是为了友好，将来会赋值对象，2、最后置为null回收
// 函数执行完，内部变量立即释放，而null垃圾对象会隔一段时间释放(被垃圾回收器)
// call是真牛逼啊 直接test.call(obj)  obj.test() 这样不给调 就叫call过来帮忙，让test函数临时成为他的属性。 
// 回调事件 点击事件等 延时定时器，  特点 我定义的 我没有调 它执行了         我只定义了 浏览器给我调
// IIFE 立即执行函数表达式    函数不会污染命名空间
// 闭包 把函数里面的函数或者变量挂到外面的某个对象上，实现永生。
// 分号问题， 以小括号或者中括号开头的前一条语句要加；
// 每个函数都有一个内置属性prototype(显式原型) 该属性指向原型对象
// 原型对象中的属性constructor 指向函数对象
// 给原型对象添加方法 ，实例对象可以访问
// 实例对象有一个属性_ _ ptoto_ _ (隐式原型)  和 fun._ _ ptoto_ _  === Fun.prototype
// 原型链 普通函数有显式原型prototype指向它的自己的原型对象(某个对象），也有隐式原型_ _ ptoto_ _ 指向Funcion的原型对象。比较普通函数是New Function出来的。所有所有函数的隐式原型都指向Funcion的原型对象。
// Function他的显式原型是指向它自身Function的原型对象。指向的原型对象中有个属性constructor会指回来(Function)。 同时Function也有一个隐式原型指向Function的显式原型所指向的原型对象，这个表明Function 是 New Function出来的，New出来的。
// Object思最顶层的对象，它的隐式原型指向Function的原型对象，他的显式原型虽然存在，但是已经不算个object对象了，它是null
// Function的显式原型指向的原型对象是算Object的实例对象滴。前面也说过Function的显式原型相关知识。
// 一切函数的隐式原型都指向Function的显示原型的原型对象。
// 一句话 实例对象的隐式原型都指向构造函数的显式原型。
// instanceof 是否是某个实例
// Object()构造函数的显示原型指向它的显示原型原型对象，被指的原型对象也是某个东西的实例，它就也有_ _ ptoto_ _ 并且指向null。
// Object()构造函数的显示原型指向它的显示原型原型对象(一切对象的_ _ ptoto_ _ 指向)
// 原型链图解 能说出来每根线的意义
// 全局上下文代码执行前 this是window赋值的，函数声明提升全提升上来，函数表达式声明的函数值当做变量提升上来(undefined)。挂在window上。
// 控制台里的函数 他不是按顺序走的，有可能已经执行过了。
// 函数的上下文执行前 会形参赋值给实参  arguments赋值  局部变量声明提升 function定义提升 this是调用的对象。
// 上下文的变量都是在对应的上下文执行前做的工作中找的。 上下文是一片虚拟空间，在执行代码前会存点东西(执行上下文)。
// 函数的上下文在调用时 才会有。调用完就释放，不然跟外面变量冲突了。
// 上下文是一种预处理的虚拟对象 空间。
// 递归是在函数内部调用自己  但是内部一般会有退出终止的条件
// 递归产生的函数上下文会嵌套起来，像栈，后进先出。执行最后进的函数，执行完后会销毁它，再执行前一个。是藉着销毁的地方继续执行未结束的代码。
// 声明提升 先提升变量 再提升函数 再赋值。
// 闭包 
// 嵌套内部函数中引用了嵌套外部函数中的变量，内部函数会把这个变量存在它的闭包对象上，可以把闭包理解成一个内部函数的属性对象吧。
// 内部函数定义的时候就产生了闭包，不用调用内部函数。但起码要调用外部函数..........
// 闭包是定义内部函数的时候产生的，也是调用外部函数的时候产生的，跟调用内部函数没关系。闭包可以延长外部函数的变量，使外面可以间接操作外部函数的变量。
// 闭包顿悟 内部函数引用的的外部函数的变量a，它会把a存在外部函数的内存中，且外部函数销毁时，不会消失。所以循环点击按钮点击的i不是最后循环的i，而是每次循环后，存在内存中的i。为什么加自执行函数就可以，是因为for没循环一次，外部函数(自执行函数)就会执行一次（内部函数就会再定义一次，而每定义一次内部函数就会产生闭包，调用内部函数不会产生新的闭包，是定义了就有），会产生多个闭包对象数据，闭包赋值后没有消失，没有置为null。
// 闭包的内部函数作为返回值，在外面调用改变外部函数变量时，怎么改全听内部函数逻辑怎么写，而内部函数的逻辑全听我的。内部函数相当于给外面提供一个接口改外部函数的值，怎么改我可以定制。内部函数执行完就会销毁，除非还有它的嵌套函数引用它，如果外面是返回值接收内部函数，是个赋值语句，那么内部return的内部函数执行完也不会成为垃圾对象，它本身的函数语句作为对象被赋值给外面的变量了，但是函数名也销毁了。只要外面有东西接收了内部函数。内部函数名说我虽然挂了，但是江湖一直有我的传说。
// 闭包为什么不消失，是因为外面接收的变量存了内部函数(赋值语句)，而内部函数有闭包的数据。所以主要是外面的变量没有消失。
//  闭包什么时候死亡，外面的变量接收的内部函数成为垃圾对象， f= null
// 闭包的应用  就是封装个js文件，向外暴露出内部函数(私有的功能)，内部函数中可以读写外部函数的变量，所以外面的也可以看到外部函数的变量了。暴露有两种，一种是直接return 内部函数 或者对象 数组。另一种是外部函数是自执行函数 直接把要返回的对象或者数组内部函数作为属性挂到window上，在外面用的时候直接对象.的方式用就行。第一种要在外面执行外部函数 用变量接收内部函数，比较麻烦，第二种是直接挂到全局的不用在外面执行外部函数了。
// 闭包缺点 占用内存过长， 导致内存泄漏(浪费空间）， 能不用就不用，及时释放，让内部函数变成垃圾对象。 f= null 
// 内存泄露与内存溢出
// 对象创建的几种方法
// 原型链继承，就是让某个构造函数的原型被赋值另一个构造函数的实例。Son.prototype = New Father()  Son可以用father原型对象上的方法了。但是需要把Son的prototype的constructor指回来，Son.prototype.constructor = Son
// 还有一种假继承 在Student构造函数中用call去偷， Person.call(this，name，age)
// 第一种可以继承到另一个构造函数的prototype上的方法，假继承可以继承另一个构造函数的本身上的方法。
// 组合继承 不仅得到另一个构造函数的prototype上的方法，还要得到另一个构造函数的本身上的方法。就是把上面两种都写一下就行了。
// 进程与线程
// 浏览器内核
// 定时器的思考
// js是单线程执行的
// 事件循环模型
// h5 worker 多线程
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
export default {
    name: "css01",
    components: {
        // HelloWorld
    },
    data() {
        return {};
    },
    mounted() {},
    computed: {},
    watch: {},
    methods: {
        buttonClick() {
            alert('不要点我啦')
            console.log('你好JS')
        }
    },
};
</script>

<style lang="less" scoped>

</style>
