<template>
    <div class="content">
        <button @click="buttonClick">点击触发事件</button>
    </div>
</template>

<script>
// @ is an alias to /src
// import HelloWorld from '@/components/HelloWorld.vue'
// \' 表示单引号   n表示换行
// typeof 检查变量类型
// NaN  算了，算出来不是一个数字。
// JS整数的运算基本正确，小数会不精确，因为计算机不能精确表示小数。可以放在服务器里运算。
// null表示一个空对象，typeof null 是object。typeof undefined  返回是undefined。
// undefined 声明但未赋值
// 强制类型转换，a.toSring()方法 不会影响原数据。Sring(a) 函数。区别是对null和undefined转的不同，前面报错，后面是直接转加‘’。
// 强制类型转换， Number(), 纯数字字符串则直接转城数字，但是非数字内容，则转成NAN。空串会转成0。true转成1，false转成0. null转成0，undefined转成NaN.
// 强制类型转换 parseInt（）从字符串中有效的整数取出来从左往右转成整型，遇到非数字就直接G。parseFloat（）能取有效的小数。不是字符串的会先转字符串再转数字。
// 0x10 16进制的数字10，但是输的时候会转换成10进制输出。0开头是8进制，0b开头是2进制数字。parseInt(a,10) 当成10进制转换。
// 强制类型转换 Boolean（） ，对于数字，除了NAN和0是false。对于字符串 除了空串是false。 null转的是false，undefined也是false。
// 算数运算符，数字 + '' 可以利用这一个特点把数字转成字符串。除了+运算符会隐形转字符串计算拼接，其余的- * / 都会隐形转数字再计算。
// 算数运算符 % 取模运算。9%3 余0.
// 一元运算符 + 正号 - 负号。+ - 会先把其他数据类型转换成number再加负号。
// 自增自减 -- ++a 代表先算完再赋值， a-- a++ 是直接复制再自增自减。
// 逻辑运算符 && || ！   返回第一个或者第二个看该运算符还管不管第二个值了， 其他代码用该值来判断truefalse） 后面再复习。
//  ture && 会执行这个。 false && 不会执行这个了。  这个运算符可以简化代码。sqw
// \u1C00 Unicode编码 在js中 \u 加前缀        在网页中&#9760  后面要跟10进制 
// isNaN() 判断是不是NaN
// 三元运算符也叫条件运算符  a？b：c   a是true执行b
// let a， b = 1， c 逗号可以声明多个变量
// 括号可以提升优先级，一人一下，万人之上。
// switch case 方法参数的值会跟case后面的值比较。值可以是表达式，两者的值全等就行。
// while 循环 有break就停止   for循环 for （let i =1； i< 100 ; i++）{}
// break 只对离他最近的for生效。 可以给外层循环起名字 xxx：   break后面跟着 xxx；
// continue可以直接跳过当次循环。 也是对离他最近的循环生效。也可以给外for起名字。
// 对象


// 内建对象 宿主对象 自定义对象
// delete 对象.属性
// 对象采用特殊的属性名 要用obj['123'] = 789  取的时候也要用obj['123']  推荐这种 因为可以传变量   n= ‘123’  obj[n]   但是中括号最后还要是字符串才行
// in 运算符检测对象是否有该属性 ‘test’ in obj  返回布尔值 原型中的也算。
// 字面量对象的属性名 可以不加引号，但是如果使用特殊的名字，必须加引号。
// var fn = New function  构造函数创建一个函数对象
// function fn（） {} 声明试函数
// var fn = function（）{} 表达式函数
//  上面三个都是存起来 没调用
// fn（）调用执行函数
// 声明形参就相当于在函数内部声明了变量，只声明未赋值。
// 调用函数时，解析器不会检查实参的类型和实参，多余的实参不会赋值。
// return 返回函数执行的结果， 可以结束函数的运行，不写等于return； 返回undefined
// 函数也可以作为一个实参传给一个形参a，此时a就是这个函数。 如果是把fn（）作为实参传，相当于把fn的返回值传过去，只写fn是把函数对象传过去，没调用。
//  加了（）是传的返回值，形参是这个函数的返回值。不加（）是把函数传过去，形参等于这个函数
// break跳过for循环，continue跳过当次循环，return跳过整个函数。 
// 函数内部再定义一个函数，内部再写b（）可以调用内部的这个函数。 
// fn（）（） 相当是fn函数的返回值是个函数，它在调用。
// 立即执行函数，声明后用括号包起来，后面加个（）。
// 函数作为一个属性存在对象的属性里，则称之为方法，本质上和函数一样，就是名字不同。
// 表达式1 && 表达式2 || 表达式3  如果1是真则执行2,2为假则不执行3,2为真则执行假。 && 比 || 优先级高一点。
// 枚举对象中的属性，for （let a in obj）{obj[n]}  【】里面可以写变量 .的方式是认死理
// 作用域一共两种，全局和函数。 全局的在页面打开时创建，关闭时销毁。
// 全局的变量都作为window的属性保存。
// 只有用var会产生变量声明提前 用var定义的声明函数的会声明提前所有 会直接提到解析器最高级且啥都过去了。 用表达式赋值的函数不会提函数体，只会定义一个变量未赋值。
// 函数作用域 在调用函数时创建作用域，函数执行完毕后作用域销毁。在函数作用域可以访问到全局变量，它会从里往外一层一层找直到全局作用域都没找到就会报错。
// 在函数作用域中使用var 也会提前到函数执行时最前面但不会被赋值。
// 在函数作用域中不使用var声明的变量都会成为全局的变量。
// 函数在调用时，解析器每次会传递一个隐含的参数叫this。 this指向的是函数执行的上下文对象。根据调用的方式不同。跟创建无关。
// 一函数调用时是指向window，用方法调用时是指向那个方法对象。
// 工厂函数创建对象 没有this代替对象，因为对象写在死在函数里面了，都是New的Objecet。
// 构造函数规范是首字母大写，构造函数调用时要加New，不加就是普通函数。                     有this代替对象了，返回的对象就是外面等待赋值的对象。
// 构造函数的执行流程，只要出现New立刻会创建一个新对象，作为返回值返回。1 立即创建一个对象，把新的对象设置为this，执行函数中的代码，把对象返回。
// per instance Person 检查一个对象是不是一个构造函数的实例。 per instance Object per是对象，则永远是true。
// this的问题是构造函数调一次就会创一个对象，功能重复，浪费内存。原型就出来了
// 原型对象出现的目的， 虽然把功能函数提到全局，在构造函数中把功能函数赋值解决了功能函数被创建多次，但是会污染全局作用域，且在全局中也不安全（会被覆盖）。
// 只要是函数，解析器都会向函数添加一个prototype对象。普通函数的原型没有任何作用，一构造函数创建的对象中都会有一个隐含的属性_proto_会指向构造函数的原型对象。
// 原型对象相当于一个公共区域，同一个类的实例都可以访问，所有可以把对象的公共功能添加到原型对象中。Person.prototype.a = '666';
// 当访问一个对象的属性或者方法时，会先在自身找，找不到会去原型对象中找。
// obj.hasOwnproPerty('name') 该方法可以只检测自身对象中有没有name。in关键字是包括了原型。
// 原型对象也有_proto_指向他的原型对象。
// 找某个属性或者方法的顺序，自身 自身的原型对象，直到自身的原型对象的原型（Object），Object没有原型对象了指向null。
// 打印某个变量 是打印他的toString（）方法返回值。可以改它自身的toSring（）。
// 垃圾回收，不用就置为null。
// 数组 也是内建对象 New Array（）。  arr[0] = 10; 读取不存在的索引不会报错会返回undefined。
// 数组的长度是它最大索引+1，无论里面连不连续。
// 数组方法 push（）添加一个或多个数据并返回新的长度。
// pop（）删除数组最后的一个数据。调用一次删一个，返回被删除的元素。
// unshift（） 和push相反 往前面加 返回新长度。
// shift和pop相反，删除前面的，调用一次删一个，返回被删除的元素
// 循环数组， for（let i=0； i< arr.length； i++）{arr[i]}
// forEach（）由我们声明 但不由我们调，浏览器调的，称为回调函数。
// slice(开始，结束) 截取数组指定元素，不包括结束索引。不会改变原数组，把截取的放在一个新数组返回。只写一个参数 会截取到最后。
// splice（开始，结束） 删除原数组数据，把删除的元素作为返回值返回。第一个参数表示开始位置，第二个参数表示删除几个。第三个参数及以后可以传入新的元素，自动插入删除的位置。 （3,0，新元素）等于把新元素插入在索引为3的位置
// 数组去重 双重循环，不如forEach+ include
// arr1.concat(arr2) 合并成数组返回，不会影响原数组。arr1.concat(arr2， arr3，'333)
// arr.join（连接符默认，） 把数组转成字符串，返回结果，不会影响原数组。可以传空串转成字符串啊。
// arr.reverse() 反转数组，会影响原数组。
// arr.sort() 数组排序，会影响原数组。默认按照Unicode编码排序。不准确，需要传回调函数。回调函数返回大于0的数，就会交换位置。
// 函数的方法，因为函数也是一个对象啊。fn.call() fn.apply() fn()都会执行函数。
// fn.call() fn.apply() 会将一个对象成为这个函数的this。fn.call(obj) 
// call(this对象，实参1，实参2...) call的实参直接写在指定this对象之后。
// apply（this对象，[实参1，实参2...]) applly要把实参写数组里。
// 函数在调用时，解析器除了每次会传递一个隐含的参数this，还有一个类数组对象arguments，所有的实参都在这里，不用写形参接收。arguments.length 实参的数量。arguments[0]对应实参1。
// arr instance Array 检测数组。type只能检测出对象。还有一个Array.isArray(arr)，也可以检测数组。
// arguments中还有一个自带属性callee，对应当前执行的函数对象。
// Date对象 它是一个构造函数，使用时需要New，New出来的对象有很多方法。
// Math对象，它是一个工具类对象，不需要New，直接传参用它的方法即可。 随机数。
// 包装类 String() Number() Boolean() 可以把基本数据类型转成对应的对象 let a = New Number（3）。可以当对象使用。
// 字符串方法
//
//
//
export default {
    name: "css01",
    components: {
        // HelloWorld
    },
    data() {
        return {};
    },
    mounted() {},
    computed: {},
    watch: {},
    methods: {
        buttonClick() {
            alert('不要点我啦')
            console.log('你好JS')
        }
    },
};
</script>

<style lang="less" scoped>

</style>
